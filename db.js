const DB_NAME='bank-ledger-db';
const DB_VERSION=1;
function openDB(){return new Promise((resolve,reject)=>{const req=indexedDB.open(DB_NAME,DB_VERSION);req.onupgradeneeded=()=>{const db=req.result;if(!db.objectStoreNames.contains('banks')){const s=db.createObjectStore('banks',{keyPath:'id',autoIncrement:true});s.createIndex('name','name',{unique:false})}if(!db.objectStoreNames.contains('entries')){const s=db.createObjectStore('entries',{keyPath:'id',autoIncrement:true});s.createIndex('bankId','bankId',{unique:false});s.createIndex('date','date',{unique:false});s.createIndex('type','type',{unique:false})}if(!db.objectStoreNames.contains('settings')){db.createObjectStore('settings',{keyPath:'key'})}};req.onsuccess=async()=>{const db=req.result;try{await seedIfEmpty(db);resolve(db)}catch(e){reject(e)}};req.onerror=()=>reject(req.error)})}
async function seedIfEmpty(db){await writeSetting(db,{key:'fiscalStartMonth',value:7});await writeSetting(db,{key:'fiscalEndMonth',value:6});if(!(await readSetting(db,'fixedDate'))) await writeSetting(db,{key:'fixedDate',value:null});if(await countStore(db,'banks')===0){const b1=await addBankInternal(db,{name:'البنك الأهلي',iban:'',openingBalance:0,createdAt:new Date().toISOString()});const b2=await addBankInternal(db,{name:'بنك مصر',iban:'',openingBalance:0,createdAt:new Date().toISOString()});const now=new Date(),y=now.getFullYear(),jy=(now.getMonth()+1)>=7?y:y-1;const sample=[{bankId:b1.id,type:'debit',description:'إيداع نقدي',date:`${jy}-07-05`,amount:1500},{bankId:b1.id,type:'credit',description:'سحب شيك',date:`${jy}-07-10`,amount:500},{bankId:b1.id,type:'debit',description:'تحويل وارد',date:`${jy}-08-02`,amount:2200},{bankId:b2.id,type:'credit',description:'رسوم بنك',date:`${jy}-07-15`,amount:75.5},{bankId:b2.id,type:'debit',description:'حصيلة مبيعات',date:`${jy}-08-07`,amount:3200},{bankId:b2.id,type:'credit',description:'تحويل صادر',date:`${jy}-08-12`,amount:1200}];for(const e of sample) await addEntryInternal(db,e)}}
function tx(db,names,mode='readonly'){return db.transaction(names,mode)}
function countStore(db,name){return new Promise((resolve,reject)=>{const r=tx(db,[name]).objectStore(name).count();r.onsuccess=()=>resolve(r.result||0);r.onerror=()=>reject(r.error)})}
function addBankInternal(db,bank){return new Promise((resolve,reject)=>{const r=tx(db,['banks'],'readwrite').objectStore('banks').add(bank);r.onsuccess=()=>resolve({...bank,id:r.result});r.onerror=()=>reject(r.error)})}
function addEntryInternal(db,entry){return new Promise((resolve,reject)=>{const r=tx(db,['entries'],'readwrite').objectStore('entries').add(entry);r.onsuccess=()=>resolve({...entry,id:r.result});r.onerror=()=>reject(r.error)})}
function writeSetting(db,setting){return new Promise((resolve,reject)=>{const r=tx(db,['settings'],'readwrite').objectStore('settings').put(setting);r.onsuccess=()=>resolve(setting);r.onerror=()=>reject(r.error)})}
function readSetting(db,key){return new Promise((resolve,reject)=>{const r=tx(db,['settings']).objectStore('settings').get(key);r.onsuccess=()=>resolve(r.result||null);r.onerror=()=>reject(r.error)})}
export const db={open:openDB,async addBank(bank){const database=await openDB();return addBankInternal(database,{name:bank.name,iban:bank.iban||'',openingBalance:Number(bank.openingBalance||0),createdAt:new Date().toISOString()})},async updateBank(bank){const database=await openDB();return new Promise((resolve,reject)=>{const r=tx(database,['banks'],'readwrite').objectStore('banks').put(bank);r.onsuccess=()=>resolve(bank);r.onerror=()=>reject(r.error)})},async deleteBank(id){const database=await openDB();const has=await new Promise((resolve,reject)=>{const idx=tx(database,['entries']).objectStore('entries').index('bankId');const rq=idx.openCursor(IDBKeyRange.only(Number(id)));rq.onsuccess=e=>{const c=e.target.result;if(c){resolve(true)}else resolve(false)};rq.onerror=()=>reject(rq.error)});if(has) throw new Error('لا يمكن حذف البنك لوجود قيود مرتبطة به.');return new Promise((resolve,reject)=>{const r=tx(database,['banks'],'readwrite').objectStore('banks').delete(Number(id));r.onsuccess=()=>resolve(true);r.onerror=()=>reject(r.error)})},async listBanks(){const database=await openDB();return new Promise((resolve,reject)=>{const r=tx(database,['banks']).objectStore('banks').getAll();r.onsuccess=()=>resolve(r.result||[]);r.onerror=()=>reject(r.error)})},async addEntry(entry){const database=await openDB();return addEntryInternal(database,{bankId:Number(entry.bankId),type:entry.type,description:entry.description,date:entry.date,amount:Number(entry.amount)})},async updateEntry(entry){const database=await openDB();return new Promise((resolve,reject)=>{const r=tx(database,['entries'],'readwrite').objectStore('entries').put(entry);r.onsuccess=()=>resolve(entry);r.onerror=()=>reject(r.error)})},async deleteEntry(id){const database=await openDB();return new Promise((resolve,reject)=>{const r=tx(database,['entries'],'readwrite').objectStore('entries').delete(Number(id));r.onsuccess=()=>resolve(true);r.onerror=()=>reject(r.error)})},async getEntries({bankId,from,to,type}={}){const database=await openDB();return new Promise((resolve,reject)=>{const store=tx(database,['entries']).objectStore('entries');let rq=bankId!=null?store.index('bankId').openCursor(IDBKeyRange.only(Number(bankId))):store.openCursor();const out=[];rq.onsuccess=e=>{const c=e.target.result;if(c){const v=c.value;if((!type||v.type===type)&&(!from||v.date>=from)&&(!to||v.date<=to)) out.push(v);c.continue()}else resolve(out)};rq.onerror=()=>reject(rq.error)})},async getSettings(keys=[]){const database=await openDB();return new Promise((resolve,reject)=>{const s=tx(database,['settings']).objectStore('settings');if(!keys.length){const r=s.getAll();r.onsuccess=()=>resolve(Object.fromEntries((r.result||[]).map(x=>[x.key,x.value])));r.onerror=()=>reject(r.error);return;}const out={};let left=keys.length;keys.forEach(k=>{const r=s.get(k);r.onsuccess=()=>{out[k]=r.result?r.result.value:null;if(--left===0) resolve(out)};r.onerror=()=>reject(r.error)})})},async setSetting(key,value){const database=await openDB();return writeSetting(database,{key,value})}};
export default db;

